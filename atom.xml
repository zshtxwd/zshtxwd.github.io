<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>雨打窗前🌧️</title>
  
  <subtitle>窗前细雨闻无声，似有悲歌又有情</subtitle>
  <link href="https://www.zshlmy.love/atom.xml" rel="self"/>
  
  <link href="https://www.zshlmy.love/"/>
  <updated>2023-09-02T04:09:10.000Z</updated>
  <id>https://www.zshlmy.love/</id>
  
  <author>
    <name>雨打窗前🌧️</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>【前端人python学习日记】基础语法【三】</title>
    <link href="https://www.zshlmy.love/posts/2023902d.html"/>
    <id>https://www.zshlmy.love/posts/2023902d.html</id>
    <published>2023-09-01T16:20:10.000Z</published>
    <updated>2023-09-02T04:09:10.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="文件操作">文件操作</h4><h5 id="操作文件的步骤">操作文件的步骤</h5><ul><li><p>打开</p></li><li><p>读写</p></li><li><p>关闭</p></li></ul><h5 id="open-打开函数">open()打开函数</h5><p><code>open(name，mode，encoding)</code></p><p>三个<strong>常用参数</strong>，<strong>encodeing</strong>其实是<strong>第四个</strong>参数，所以我们用<strong>关键字传参</strong>，而不是位置传参</p><p><code>f=open(&quot;D:/测试.txt&quot;,&quot;r&quot;,encoding=&quot;UTF-8&quot;)</code></p><p>​<strong>name</strong>要打开的目标文件名的字符串(可以包含目标文件的具体路径)</p><p>​<strong>mode</strong>设置文件的访问模式(<strong>只读</strong>，<strong>写入</strong>，<strong>追加</strong>)</p><p>​<strong>encoding</strong>编码格式，推荐使用<strong>UTF-8</strong></p><p><strong>mode</strong>常用的三种访问模式</p><p><img src="https://imgbed.zshlmy.love/Typora/image-20230901220551881.png" alt="image-20230901220551881"></p><h5 id="读操作的相关方法">读操作的相关方法</h5><ul><li><strong>文件对象.read(num)</strong></li></ul><p>读取文件内容，<strong>num</strong>为读取文件的字节数，不传入<strong>num</strong>则读取所有数据</p><ul><li><strong>文件对象.readlines()方法</strong></li></ul><p>readlines可以按照<strong>行</strong>的方式，把<strong>整个文件内容</strong>一次性读取，返回一个<strong>列表</strong>，<strong>每一行数据为一个元素</strong></p><ul><li><strong>文件对象.readline()方法</strong></li></ul><p>readlines可以按照<strong>行</strong>的方式，<strong>一行一行</strong>的读取文件内容</p><hr><p>在程序中连续调用两次<code>read</code>，第一次读取的结尾会被记录下来</p><p>第二次调用<code>read</code>的时候，会从<strong>第一次的结尾</strong>继续读</p><p>在<strong>读文件</strong>的时候，只要文件打开，不管调用什么方法，文件都会从<strong>上一次读的结束位置继续开始</strong></p><hr><p>可以使用for一行一行的遍历文件内容</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> line <span class="keyword">in</span> <span class="built_in">open</span>(<span class="string">&quot;python.txt&quot;</span>,<span class="string">&quot;r&quot;</span>):</span><br><span class="line">    <span class="built_in">print</span>(line)</span><br></pre></td></tr></table></figure><h5 id="close-关闭函数">close()关闭函数</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">f=<span class="built_in">open</span>(<span class="string">&quot;python.txt&quot;</span>,<span class="string">&quot;r&quot;</span>)</span><br><span class="line">f.close()</span><br></pre></td></tr></table></figure><p>通过close关闭文件，如果不使用close关闭文件，并且<strong>不结束程序</strong>，那么python会一直<strong>占用该文件</strong></p><h5 id="with-open语法">with open语法</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> <span class="built_in">open</span> (<span class="string">&quot;python.txt&quot;</span>,<span class="string">&quot;r&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    f.read()</span><br></pre></td></tr></table></figure><p>通过<strong>with open</strong>操作文件，可以在操作完成后<strong>自动调用close</strong>进行关闭</p><h5 id="基本写操作">基本写操作</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">f=<span class="built_in">open</span>(<span class="string">&quot;python.txt&quot;</span>,<span class="string">&quot;w&quot;</span>)</span><br><span class="line"><span class="comment">#打开文件</span></span><br><span class="line">f.write(<span class="string">&quot;hello world&quot;</span>)</span><br><span class="line"><span class="comment">#将内容写入内存中</span></span><br><span class="line">f.flush()</span><br><span class="line"><span class="comment">#将内存中的内容刷到硬盘上</span></span><br></pre></td></tr></table></figure><p><strong>write</strong>并<strong>没有完成文件写入</strong>的操作，只是<strong>将内容暂时存到内存中</strong>，等<strong>flush</strong>执行时将<strong>内存</strong>中的内容<strong>统一写入</strong>硬盘</p><p>这样的好处是<strong>不需要频繁操作硬盘导致效率下降</strong></p><p>前端OS：这让我想到vue框架，收集dom操作，最后统一渲染到页面上去，这样就提高了效率和资源损耗，也让我想到了使用canvas画板，在画完东西之后，需要执行stroke()才能真正画出东西</p><h5 id="基本追加操作">基本追加操作</h5><p>不会像w一样覆盖原有内容，而是在原有内容后面接着写</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">f=<span class="built_in">open</span>(<span class="string">&quot;python.txt&quot;</span>,<span class="string">&quot;a&quot;</span>)</span><br><span class="line"><span class="comment">#打开文件</span></span><br><span class="line">f.write(<span class="string">&quot;hello world&quot;</span>)</span><br><span class="line"><span class="comment">#将内容写入内存中</span></span><br><span class="line">f.flush()</span><br><span class="line"><span class="comment">#将内存中的内容刷到硬盘上</span></span><br></pre></td></tr></table></figure><p><strong>write</strong>并<strong>没有完成文件写入</strong>的操作，只是<strong>将内容暂时存到内存中</strong>，等<strong>flush</strong>执行时将<strong>内存</strong>中的内容<strong>统一写入</strong>硬盘</p><h4 id="异常">异常</h4><p>这还用我解释？</p><p><strong>遇到bug的两种处理方式</strong></p><ul><li>不去理会，程序崩溃终止运行</li><li>对bug进行处理，程序继续运行</li></ul><h5 id="捕获异常">捕获异常</h5><ul><li>捕获常规异常</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    可能出现异常的代码</span><br><span class="line"><span class="keyword">except</span>:</span><br><span class="line">    出现异常的操作</span><br></pre></td></tr></table></figure><ul><li>捕获指定类型异常</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    可能出现异常的代码</span><br><span class="line"><span class="keyword">except</span> NameError <span class="keyword">as</span> e:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;出现了变量未定义的异常&quot;</span>)</span><br></pre></td></tr></table></figure><ul><li>捕获多个异常</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    可能出现异常的代码</span><br><span class="line"><span class="keyword">except</span> (NameError,ZeroDivisionError):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;出现了变量未定义异常 或者 出现了除零异常&quot;</span>)</span><br></pre></td></tr></table></figure><ul><li>捕获所有异常</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    可能出现异常的代码</span><br><span class="line"><span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;出现了异常&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(e)</span><br><span class="line">    </span><br><span class="line"><span class="comment">#或者</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    可能出现异常的代码</span><br><span class="line"><span class="keyword">except</span>:</span><br><span class="line">    出现异常的操作</span><br></pre></td></tr></table></figure><h5 id="异常的else和finally语法">异常的else和finally语法</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    可能出现异常的代码</span><br><span class="line"><span class="keyword">except</span>:</span><br><span class="line">    异常处理</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    没出现异常的情况</span><br><span class="line"><span class="keyword">finally</span>:</span><br><span class="line">    无论是否出现异常都会执行</span><br></pre></td></tr></table></figure><p>前端OS：这finally好像promise的finally啊</p><h5 id="异常的传递性">异常的传递性</h5><p>当函数func01中发生异常，并且没有捕获处理这个异常的时候，异常会传递到函数func02，当func02也没有捕获处理这个异常的时候main函数会捕获这个异常，这就是异常的传递性</p><p>前端OS：连续使用promise，可以在最后使用catch统一捕获错误</p><p><img src="https://imgbed.zshlmy.love/Typora/image-20230901235313885.png" alt="image-20230901235313885"></p><h4 id="模块Module">模块Module</h4><p>前端OS：没必要解释，懂的都懂</p><h5 id="模块的导入">模块的导入</h5><p><strong><code>[from 模块名] import [模块|类|变量|函数|*] [as 别名]</code></strong></p><p><code>from</code>和<code>as</code>可以不写</p><h5 id="自定义模块">自定义模块</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#test.py</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">plus</span>(<span class="params">a,b</span>):</span><br><span class="line">    <span class="keyword">return</span> a+b</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#当前文件</span></span><br><span class="line"><span class="keyword">import</span> test</span><br><span class="line">test.plus(<span class="number">1</span>,<span class="number">2</span>)</span><br></pre></td></tr></table></figure><p>自定义模块的模块名，就是py文件名</p><p>引入同名的模块，类，变量，函数，后面引入的会覆盖前面引入的</p><h5 id="mian">__mian__</h5><p>只有在自己原本的文件中<code>__name__==&quot;__mian__&quot;</code>，这样可以在自定义模块中测试，又不用担心在引入模块时函数就调用</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">plus</span>(<span class="params">a,b</span>):</span><br><span class="line">    <span class="keyword">return</span> a+b</span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">&quot;__mian__&quot;</span>:</span><br><span class="line">    plus(<span class="number">1</span>,<span class="number">2</span>)</span><br></pre></td></tr></table></figure><h5 id="all">__all__</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#test.py</span></span><br><span class="line">__all__=[<span class="string">&#x27;test_A&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">test_A</span>(<span class="params">a,b</span>):</span><br><span class="line">    <span class="keyword">return</span> a-b</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">test_B</span>(<span class="params">a,b</span>):</span><br><span class="line">    <span class="keyword">return</span> a+b</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> test <span class="keyword">import</span> *</span><br><span class="line"><span class="comment">#这里使用*</span></span><br><span class="line"><span class="comment">#如果没有写__all__，那么引入所有内容</span></span><br><span class="line"><span class="comment">#如果写了__all__，那么只引入__all__中准备的内容</span></span><br></pre></td></tr></table></figure><h5 id="自定义包">自定义包</h5><p>只有文件夹里有**__init__.py<strong>文件，才被称之为</strong>包**</p><p>__init__.py文件可以<strong>没有内容</strong>，但<strong>必须存在</strong></p><p>__init__.py文件里会写__all__的配置</p><h5 id="第三方包安装">第三方包安装</h5><p><code>pip install -i https://pypi.tuna.tsinghua.edu.cn/simple 包名称</code></p><p>在<strong>pip</strong>中使用清华大学提供的镜像下载第三方包</p><h4 id="JSON">JSON</h4><p>JSON数据格式用于在各种编程语言之间传递数据</p><p>前端OS：我可太熟悉了，我说怎么字典第一眼看上去这么眼熟，原来就是JSON</p><p><code>JSON</code>和<code>python</code>中的<strong>字典</strong>，<strong>列表嵌套字典</strong>可以无缝切换，不能说相似吧，只能说是一模一样</p><h5 id="JSON数据转化">JSON数据转化</h5><p>将JSON数据与python数据之间互相转化</p><p>前端OS：是不是<code>JSON.stringfly</code>和<code>JSON.parse</code>啊？</p><ul><li>引入JSON库</li></ul><p><code>import json</code></p><ul><li>python数据转化成JSON数据</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">data=[&#123;<span class="string">&quot;name&quot;</span>:<span class="string">&quot;张三&quot;</span>,<span class="string">&quot;age&quot;</span>:<span class="number">18</span>&#125;,&#123;<span class="string">&quot;name&quot;</span>:<span class="string">&quot;李四&quot;</span>,<span class="string">&quot;age&quot;</span>:<span class="number">19</span>&#125;]</span><br><span class="line"></span><br><span class="line">data=json.dumps(data)</span><br><span class="line"><span class="comment">#将python数据转为JSON字符串</span></span><br><span class="line"></span><br><span class="line">data=json.loads(data)</span><br><span class="line"><span class="comment">#将JSON字符串转为python数据</span></span><br></pre></td></tr></table></figure><p>中文转换时会有编码问题，我们可以设置**<code>ensure_ascii=False</code>**</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> json</span><br><span class="line"></span><br><span class="line">data=[&#123;<span class="string">&quot;name&quot;</span>:<span class="string">&quot;张三&quot;</span>,<span class="string">&quot;age&quot;</span>:<span class="number">18</span>&#125;,&#123;<span class="string">&quot;name&quot;</span>:<span class="string">&quot;李四&quot;</span>,<span class="string">&quot;age&quot;</span>:<span class="number">19</span>&#125;]</span><br><span class="line"></span><br><span class="line">data=json.dumps(data,ensure_ascii=<span class="literal">False</span>)</span><br><span class="line"><span class="comment">#将python转为JSON</span></span><br><span class="line"><span class="comment">#设置ensure_ascii=False的意思是不使用ascii来转换他，把内容直接输出出去</span></span><br><span class="line"><span class="comment">#如果不设置，那么中文就会变成unicode字符</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">🐍变强，赚很多钱给她更好的</summary>
    
    
    
    <category term="python学习日记" scheme="https://www.zshlmy.love/categories/python%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/"/>
    
    
    <category term="python" scheme="https://www.zshlmy.love/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>【前端人python学习日记】基础语法【二】</title>
    <link href="https://www.zshlmy.love/posts/2023901d.html"/>
    <id>https://www.zshlmy.love/posts/2023901d.html</id>
    <published>2023-08-31T16:39:10.000Z</published>
    <updated>2023-08-31T16:39:10.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="数据容器">数据容器</h3><p>根据特点不同</p><ul><li>是否允许元素重复</li><li>是否可以修改</li><li>是否有序</li></ul><p>等，可以分为5类列表<code>list</code>、元组<code>tuple</code>、字符串<code>str</code>、集合<code>set</code>、字典<code>dict</code></p><h4 id="列表List">列表List</h4><p>前端OS:中括号，能用索引下标取，是数组！！！</p><h5 id="字面量">字面量</h5><p><code>[元素1，元素2，元素3，元素4]</code></p><h5 id="定义变量">定义变量</h5><p><code>变量名称=[元素1，元素2，元素3，元素4]</code></p><h5 id="定义空列表">定义空列表</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">变量名称=[]</span><br><span class="line">变量名称=<span class="built_in">list</span>()</span><br></pre></td></tr></table></figure><h5 id="数据类型">数据类型</h5><p>使用<code>type</code>输出类型，结果为<code>&lt;class 'list'&gt;</code></p><h5 id="下标索引">下标索引</h5><p>长度为n的列表</p><p>正向第一个元素下标是<code>0</code>，最后一个元素下标是<code>n-1</code></p><p>反向第一个元素下标是<code>-1</code>，最后一个元素(也就是第一个元素)，索引值是<code>-n</code></p><p><strong>下标索引取值</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">myList=[<span class="string">&quot;hello&quot;</span>,<span class="number">69</span>,<span class="number">13.14</span>,[<span class="number">36</span>,<span class="string">&quot;world&quot;</span>]]</span><br><span class="line"><span class="built_in">print</span>(myList[-<span class="number">2</span>])   <span class="comment">#13.14</span></span><br><span class="line"><span class="built_in">print</span>(myList[<span class="number">0</span>])    <span class="comment">#&quot;hello&quot;</span></span><br><span class="line"><span class="built_in">print</span>(myList[<span class="number">3</span>][<span class="number">1</span>]) <span class="comment">#world</span></span><br></pre></td></tr></table></figure><h5 id="列表操作">列表操作</h5><p><strong>查找元素</strong></p><p><code>列表.index(目标元素)</code>index会返回<strong>目标元素</strong>的下标</p><p>如果查找的元素不存在会<strong>报错</strong></p><p>前端OS:<code>js</code>的<code>index</code>如果元素不存在会返回<code>-1</code>，但是python中<code>-1</code>也是索引，指的是最后一个元素</p><p><strong>插入元素</strong></p><p><code>列表.insert(插入位置,要插入的元素)</code>例如<code>myList.insert(1,&quot;python&quot;)</code></p><p>在索引值为1的地方插入’python’，本来在索引值为1的元素会<strong>往后移动</strong></p><p>​<strong>如果插入的位置索引超出列表的长度会报错</strong></p><p><strong>追加元素</strong></p><ul><li>单个元素</li></ul><p>​<code>列表.append(目标元素)</code>将<strong>目标元素</strong>添加到列表尾部</p><ul><li>多个元素</li></ul><p>​<code>列表.extend(其他元素容器)</code>将<strong>其他元素容器</strong>的内容取出，依次添加到列表尾部</p><p>​<code>[0,1,2].extend([3,4,5])</code>会把<code>[0,1,2]</code>这个数组变成<code>[0,1,2,3,4,5]</code></p><p><strong>删除元素</strong></p><ul><li><code>del</code>关键字</li></ul><p>​<code>del 目标列表[索引]</code></p><ul><li><code>pop</code>方法</li></ul><p>​<code>目标列表.pop(索引)</code></p><p>​实际上是取出列表中的某个元素，这个方法的返回值是被取出的元素</p><p><strong>清空列表</strong></p><p><code>列表.clear()</code>例如<code>myList.clear()</code></p><p><strong>修改元素</strong></p><ul><li>修改特定位置的元素(重新赋值)</li></ul><p>​<code>列表[索引]=要修改的值</code>例如<code>myList[2]=&quot;python&quot;</code></p><ul><li>删除某个元素在列表中的<strong>第一个匹配项</strong></li></ul><p>​<code>列表.remove(元素)</code>例如<code>myList[2]=&quot;python&quot;</code></p><p><strong>统计元素个数</strong></p><p><code>列表.count(目标元素)</code>统计<strong>目标元素</strong>在列表中的个数</p><p><strong>列表长度</strong></p><p><code>len(列表)</code>统计列表中的元素个数</p><p><img src="https://imgbed.zshlmy.love/Typora/image-20230828000709418.png" alt="image-20230828000709418"></p><h4 id="元组Tuple">元组Tuple</h4><p>一个只读的list，可以储存多种类型的数据，修改其中的元素会报错，但列表作为元组的一个元素，列表内部的值是可以改变的</p><p>前端OS:一个不能操作的数组，尤其是作为元组元素的列表内部的值是可以改变的，简直像是const arr=[[1,2,3],4,5,“hello”]</p><h5 id="字面量-2">字面量</h5><p><code>(元素1，元素2，元素3，元素4)</code></p><h5 id="定义变量-2">定义变量</h5><p><code>变量名称=(元素1，元素2，元素3，元素4)</code></p><h5 id="定义空元组">定义空元组</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">变量名称=()</span><br><span class="line">变量名称=<span class="built_in">tuple</span>()</span><br></pre></td></tr></table></figure><h5 id="数据类型-2">数据类型</h5><p>使用<code>type</code>输出类型，结果为<code>&lt;class 'tuple'&gt;</code></p><h5 id="下标索引-2">下标索引</h5><p><strong>同<code>list</code></strong></p><h5 id="元组操作">元组操作</h5><p>只支持**<code>index</code>,<code>len()</code>,<code>count()</code><strong>，且使用方法</strong>同<code>list</code>**</p><p><img src="https://imgbed.zshlmy.love/Typora/image-20230828002848175.png" alt="image-20230828002848175"></p><h4 id="字符串String">字符串String</h4><p>前端OS：这就是字符串，嗯</p><h5 id="定义变量-3">定义变量</h5><p><code>str=&quot;hello world&quot;</code></p><h5 id="下标索引-3">下标索引</h5><p>可以使用下标索引取值，<code>js</code>中也可以，但我很少去用</p><h5 id="字符串操作">字符串操作</h5><p><img src="https://imgbed.zshlmy.love/Typora/image-20230831215523354.png" alt="image-20230831215523354"></p><h4 id="序列">序列</h4><p><strong>序列支持切片</strong></p><p><strong>列表，元组，字符串，均支持切片操作</strong></p><p><strong>语法:<code>序列[开始位置:结束位置:步长]</code></strong></p><p>可以<strong>参数不传</strong>，默认值开始位置为<strong>数据容器起点</strong>，结束位置为<strong>数据容器终点</strong>，步长默认为<strong>1</strong></p><p>切片的起始位置默认为 0，即第一个元素的索引为 0。切片操作<strong>包括起点</strong>，但<strong>不包括终点</strong></p><h4 id="集合set">集合set</h4><p><strong><code>列表</code><strong>支持</strong>修改</strong>，支持<strong>重复元素</strong>，<strong>有序</strong></p><p><strong><code>字符串</code></strong>，<strong><code>元组</code></strong> <strong>不支持修改</strong>，支持<strong>重复元素</strong>，<strong>有序</strong></p><p><strong><code>集合</code><strong>最大的特点，<strong>不支持重复元素</strong>，<strong>无序</strong>(无序就说明，不支持下标索引访问)，允许</strong>修改</strong></p><p>前端OS：出现了！集合！！！</p><h5 id="定义集合">定义集合</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">test=&#123;<span class="string">&quot;string&quot;</span>,<span class="string">&quot;list&quot;</span>,<span class="string">&quot;tuple&quot;</span>,<span class="string">&quot;set&quot;</span>,<span class="string">&quot;string&quot;</span>,<span class="string">&quot;set&quot;</span>&#125;</span><br><span class="line"><span class="comment">#输出test</span></span><br><span class="line"><span class="comment">#&#123;&quot;string&quot;,&quot;list&quot;,&quot;tuple&quot;,&quot;set&quot;&#125;</span></span><br></pre></td></tr></table></figure><p>定义时元素可以重复</p><p>输出时自动去重</p><h5 id="集合操作">集合操作</h5><h5 id="集合遍历">集合遍历</h5><p>因为<strong>不支持下标索引</strong>所以<strong>不能使用while遍历</strong></p><p>但可以使用<strong>for遍历</strong></p><p><img src="https://imgbed.zshlmy.love/Typora/image-20230831223236393.png" alt="image-20230831223236393"></p><h4 id="字典">字典</h4><p>不支持下标索引，<strong>无序</strong>，<strong>key不可重复</strong></p><p>使用花括号<code>&#123;&#125;</code>，储存键值对<code>key:value</code></p><p>前端OS：我觉得是js里最好用的数据容器了</p><h5 id="定义字典">定义字典</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dict1=&#123;&#125;</span><br><span class="line">dict2=<span class="built_in">dict</span>()</span><br><span class="line">dict3=&#123;<span class="string">&quot;周杰伦&quot;</span>:<span class="number">100</span>,<span class="string">&quot;扁嘴伦&quot;</span>:<span class="number">102</span>,<span class="string">&quot;郭艾伦&quot;</span>:<span class="number">98</span>&#125;</span><br></pre></td></tr></table></figure><p><strong>不允许key重复</strong>，同名的key，后面的会<strong>覆盖</strong>前面的</p><h5 id="字典取值">字典取值</h5><p><code>number=dict3[&quot;扁嘴伦&quot;]</code></p><h5 id="字典嵌套">字典嵌套</h5><p>字典可以作为字典某一个key的value，来实现字典的<strong>嵌套</strong></p><p><strong>字典可嵌套，取值可叠加</strong></p><p>字典的键（key）可以是以下数据类型：</p><p>不可变数据类型：</p><ul><li>字符串（string）</li><li>数字（integer、float、complex）</li><li>布尔值（boolean）</li><li>元组（tuple）</li></ul><p>内置的哈希类型：</p><ul><li>字节串（bytes）</li></ul><p>字典的键必须是<strong>不可变的</strong>，因为字典使用<strong>哈希表</strong>来实现快速查找和访问。可变的数据类型（如列表）不能用作字典的键，因为它们的哈希值可以发生变化，从而破坏了字典的内部结构。</p><h5 id="字典操作">字典操作</h5><p><img src="https://imgbed.zshlmy.love/Typora/image-20230831225922087.png" alt="image-20230831225922087"></p><h4 id="数据容器对比">数据容器对比</h4><table><thead><tr><th></th><th>列表</th><th>元组</th><th>字符串</th><th>集合</th><th>字典</th></tr></thead><tbody><tr><td>元素数量</td><td>多个</td><td>多个</td><td>多个</td><td>多个</td><td>多个</td></tr><tr><td>元素类型</td><td>任意</td><td>任意</td><td>字符</td><td>任意</td><td>键值对</td></tr><tr><td>重复元素</td><td>支持</td><td>支持</td><td>支持</td><td>不支持</td><td>不支持</td></tr><tr><td>下标索引</td><td>支持</td><td>支持</td><td>支持</td><td>不支持</td><td>不支持</td></tr><tr><td>是否只读</td><td>否</td><td>只读</td><td>只读</td><td>否</td><td>否</td></tr><tr><td>使用场景</td><td>可修改可重复的数据</td><td>不可修改可重复的数据</td><td>一串字符串</td><td>不可重复的数据</td><td>以key检索value，有对应关系</td></tr></tbody></table><h5 id="数据容器通用操作">数据容器通用操作</h5><p>多数数据容器都支持下标索引取值，所以多数数据容器都支持<code>while</code>遍历</p><p>数据容器都支持<code>for</code>遍历</p><p>数据容器的通用方法<code>len()</code>,<code>min()</code>,<code>max()</code></p><p>数据容器间可以<strong>互相转化</strong>，注意<strong>字典</strong>和<strong>字符串</strong>在转换成<strong>其他数据容器</strong>时会<strong>有变化</strong>，例如字典转换成列表就只剩<code>key</code>，而丢掉了<code>value</code></p><p>**<code>sorted(数据容器,[reverse=True])</code>**第二个参数默认为<code>False</code></p><p>将数据容器排序按**<code>从小到大</code><strong>的顺序排序，如果第二个参数传<code>True</code>则</strong><code>从大到小</code><strong>排序，然后放进</strong>列表**里,你懂的，看上面↑</p><p>字母的大小取决于他的<code>ascii</code>值</p><p><img src="https://imgbed.zshlmy.love/Typora/image-20230831232707221.png" alt="image-20230831232707221"></p>]]></content>
    
    
    <summary type="html">🐍挺有意思的编程语言</summary>
    
    
    
    <category term="python学习日记" scheme="https://www.zshlmy.love/categories/python%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/"/>
    
    
    <category term="python" scheme="https://www.zshlmy.love/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>【前端人python学习日记】基础语法【一】</title>
    <link href="https://www.zshlmy.love/posts/2023826d.html"/>
    <id>https://www.zshlmy.love/posts/2023826d.html</id>
    <published>2023-08-26T12:13:52.000Z</published>
    <updated>2023-08-31T16:30:00.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="数据类型">数据类型</h3><h4 id="基本类型">基本类型</h4><ul><li>字符串类型</li><li>整型（有符号）</li><li>浮点型（有符号）</li></ul><h5 id="查看数据类型">查看数据类型</h5><p><code>type()</code>会返回数据的类型</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(<span class="string">&quot;hello world&quot;</span>))</span><br><span class="line">int_data=<span class="number">520</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(int_data))</span><br><span class="line">float_data=<span class="number">13.14</span></span><br><span class="line">float_type=<span class="built_in">type</span>(float_data)</span><br><span class="line"><span class="built_in">print</span>(float_type)</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">输出</span></span><br><span class="line"><span class="string">&lt;class &quot;str&quot;&gt;</span></span><br><span class="line"><span class="string">&lt;class &quot;int&quot;&gt;</span></span><br><span class="line"><span class="string">&lt;class &quot;float&quot;&gt;</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure><h5 id="类型转换">类型转换</h5><p><code>float(),int(),str()</code>改变数据类型</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int_data=<span class="built_in">int</span>(<span class="string">&quot;11&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(int_data),int_data)</span><br></pre></td></tr></table></figure><p><strong>注意点</strong></p><p>不是所有字符串都能转整型、浮点型，如果字符串不全是数字执行时会报错</p><p>整型转浮点型会带上小数部分，例如<code>11</code>转成<code>11.0</code></p><p>浮点型转整型会丢失小数部分，例如<code>11.353</code>转成<code>11</code></p><h4 id="标识符-变量名">标识符(变量名)</h4><p><strong>命名规则</strong></p><ul><li>英文</li><li>中文(不推荐使用中文)</li><li>数字(不可以用在开头)</li><li>下划线(_)</li></ul><p>这四类元素</p><p><strong>标识符区分大小写</strong></p><p><strong>不可使用关键字(保留字)</strong></p><h4 id="运算符">运算符</h4><h5 id="算术运算符">算术运算符</h5><ul><li><code>+</code>加</li><li><code>-</code>减</li><li><code>*</code>乘</li><li><code>/</code>除</li><li><code>//</code>整除运算符<code>9//2=4</code></li><li><code>%</code>取余运算符<code>9%2=1</code></li><li><code>**</code>指数运算符<code>2**3=8</code></li></ul><h5 id="赋值运算符">赋值运算符</h5><ul><li><code>=</code>把右边的数据赋值给左边的变量</li><li><code>+=</code></li><li><code>-=</code></li><li><code>*=</code></li><li><code>/=</code></li><li><code>%=</code></li><li><code>//=</code></li><li><code>**=</code>幂赋值运算符,<code>a**=c</code>相当于<code>a=a**c</code></li></ul><h4 id="字符串">字符串</h4><h5 id="字符串的三种定义方式">字符串的三种定义方式</h5><ul><li><p>单引号<code>str='str1'</code></p></li><li><p>双引号<code>str=&quot;str2&quot;</code></p></li><li><p>三引号<code>str=&quot;&quot;&quot;str3&quot;&quot;&quot;</code>三引号支持多行数据</p></li></ul><p>如果字符串本身包含引号可以，使用其他的引号定义，也可以使用转义符**(\)**来解除引号的作用</p><h5 id="字符串拼接">字符串拼接</h5><p>使用**+**来进行字符串拼接</p><p>注意和<strong>js</strong>不同的是：字符串不能直接通过**+**来和整型或者浮点型进行拼接，否则会报类型错误</p><p>我们可以使用<strong>字符串格式化</strong>来进行字符串类型和整型的拼接</p><h5 id="字符串格式化">字符串格式化</h5><p>使用**%**进行占位</p><p>使用<strong>s</strong>表示将数据变成字符串放到占位的地方</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">tel=<span class="number">15151226564</span></span><br><span class="line">money=<span class="number">20.365</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;我的电话号码是%s,我的钱包余额是%s&quot;</span>%(tel,money))</span><br><span class="line"><span class="comment">#输出:我的电话号码是15151226564,我的钱包余额是20.365</span></span><br></pre></td></tr></table></figure><p>多个变量拼接使用括号括起来，用逗号分隔，按照输入顺序填入占位的地方</p><p><code>%s</code>字符串占位</p><p><code>%d</code>整型占位</p><p><code>%f</code>浮点型占位</p><h5 id="字符串格式化：数字精度控制">字符串格式化：数字精度控制</h5><ul><li><code>m</code>控制字符串宽度，设置的宽度小于数字本身<strong>不生效</strong></li><li><code>.n</code>控制小数点精度，要求是数字，会进行<strong>四舍五入</strong></li></ul><p><code>%5d</code>设置宽度为5，宽度不足会在前面补上<strong>空格</strong></p><p><code>%.2</code>设置小数点精度为2</p><p><code>%5.2f</code>设置宽度为5，小数点精度为2，小数部分也计入宽度</p><h5 id="字符串格式化：快速写法">字符串格式化：快速写法</h5><p>不理会类型，不做精度控制</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">name=<span class="string">&quot;张三&quot;</span></span><br><span class="line">age=<span class="number">18</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;我的名字是<span class="subst">&#123;name&#125;</span>,我的年龄是<span class="subst">&#123;age&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure><p>类似<strong>js</strong>的模板字符串</p><h5 id="字符串格式化：表达式格式化">字符串格式化：表达式格式化</h5><p><strong>表达式</strong>是指有明确执行结果的代码语句</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">str</span>=<span class="string">&quot;hello world&quot;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;str的数据类型是%s&quot;</span>%(<span class="built_in">type</span>(<span class="built_in">str</span>)))</span><br></pre></td></tr></table></figure><h4 id="Input和print">Input和print</h4><p>print是输出</p><p>input是输入</p><h5 id="input">input</h5><p>input输入完成后使用回车键完成输入</p><p>input需要使用一个变量接收输入的值<code>str=input()</code></p><p>input可以接收一个参数，进行输入提示</p><p>input接收输入的数据会变成字符串类型</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">str</span>=<span class="built_in">input</span>(<span class="string">&quot;验证input获取到的数据类型?\n&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;数据类型是<span class="subst">&#123;<span class="built_in">type</span>(<span class="built_in">str</span>)&#125;</span>&quot;</span>)</span><br><span class="line"><span class="comment">#输出：数据类型是&lt;class &#x27;str&#x27;&gt;</span></span><br></pre></td></tr></table></figure><h5 id="print">print</h5><p><code>print()</code> 函数有一个名为 <code>end</code> 的可选参数，它决定了在输出内容后要添加什么字符作为结尾，默认情况下是换行符 <code>\n</code></p><p><strong>end参数</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&quot;hello&quot;</span>,end=<span class="string">&quot;&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;world&quot;</span>,end=<span class="string">&quot;&quot;</span>)</span><br></pre></td></tr></table></figure><h4 id="判断语句">判断语句</h4><h5 id="布尔类型">布尔类型</h5><p>进行判断只有两个结果<strong>真</strong>或<strong>假</strong></p><p><code>True</code>表示真，<code>False</code>表示假</p><p><code>True</code>本质上是数字记作<strong>1</strong>，<code>False</code>记作<strong>0</strong></p><p><code>print(3+True)</code>输出4</p><p><code>print(3+True-False)</code>输出4</p><h5 id="比较运算符">比较运算符</h5><ul><li><code>&gt;</code></li><li><code>&lt;</code></li><li><code>==</code></li><li><code>!=</code></li><li><code>&gt;=</code></li><li><code>&lt;=</code></li></ul><h5 id="if判断语句">if判断语句</h5><p>if 判断条件 :</p><p>[空格]条件成立的执行语句</p><p>**python中使用空格来确定语句归属，需要4个空格，一个tab就是4个空格 **</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="number">10</span>&gt;<span class="number">5</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;10确实大于5&quot;</span>)</span><br></pre></td></tr></table></figure><p><strong>else</strong></p><p><code>else</code>和<code>if</code>同级，<code>else</code>是判断语句的一个分支，用来兜底，当其他分支不执行时，执行<code>else</code></p><p><strong>elif</strong></p><p><code>elif</code>和<code>else</code>和<code>if</code>同级，<code>elif</code>是判断语句的一个分支</p><h4 id="循环语句">循环语句</h4><h5 id="while循环语句">while循环语句</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">i=<span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> i&lt;<span class="number">100</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;hello world %d&quot;</span>%i)</span><br><span class="line">    i+=<span class="number">1</span></span><br></pre></td></tr></table></figure><p><code>while</code>后面的是循环条件，<code>while</code>条件需要得到布尔类型，<code>True</code>是继续循环，<code>False</code>是停止循环</p><p>一定要<strong>设置循环终止条件</strong>，否则会<strong>无限循环</strong></p><p><strong>缩进</strong>的要求同<code>if判断语句</code></p><h5 id="while循环嵌套">while循环嵌套</h5><p><strong>一定要注意重置内循环的状态，否则内循环只循环一次！！！</strong></p><h5 id="for循环">for循环</h5><p><code>while</code>本质上更像循环</p><p><code>for</code>本质上更像遍历和迭代</p><p><code>while</code> 循环像是一个开放式的“如果……那么”语句，只要条件为真，就会重复执行。而 <code>for</code> 循环像是一个计数的机制，用于遍历一系列元素</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> <span class="string">&quot;hello world&quot;</span>:</span><br><span class="line">    <span class="built_in">print</span>(x)</span><br></pre></td></tr></table></figure><p>将hello world的字符串遍历，并赋予x临时变量</p><p>理论上for循环不可能无限循环，因为<code>in</code>的数据处理集不可能无限大</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">str</span>=<span class="string">&quot;skdfkshkhkhfsadhkas&quot;</span></span><br><span class="line">i=<span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">str</span> :</span><br><span class="line">    <span class="keyword">if</span>(x==<span class="string">&quot;s&quot;</span>):</span><br><span class="line">        i+=<span class="number">1</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;s一共出现了%d次&quot;</span>%i)</span><br></pre></td></tr></table></figure><p><strong>for循环的变量作用域</strong></p><p>临时变量在编程规范上，只限度在<code>for</code>内部</p><p>如果在<code>for</code>外部访问临时变量是可以访问的</p><p>在编程规范上不建议这么做</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>):</span><br><span class="line">    <span class="built_in">print</span>(i)</span><br><span class="line"><span class="built_in">print</span>(i)</span><br><span class="line"><span class="comment">#最后的i输出4</span></span><br></pre></td></tr></table></figure><h5 id="countine关键字">countine关键字</h5><p>终止本次循环，直接进入下一次循环</p><p>在<code>for</code>和<code>while</code>中有同样的作用</p><p>在嵌套中使用，只对<strong>当前循环</strong>生效</p><h5 id="break关键字">break关键字</h5><p>直接结束循环</p><p>在<code>for</code>和<code>while</code>中有同样的作用</p><p>在嵌套中使用，只对<strong>当前循环</strong>生效，记住他只是结束了当前循环，不是把当前循环代码删了</p><h4 id="函数">函数</h4><p>提高代码复用性和开发效率</p><h5 id="函数的定义">函数的定义</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">函数名</span>(<span class="params">参数</span>):</span><br><span class="line">    函数体</span><br><span class="line">    <span class="keyword">return</span> 返回值</span><br></pre></td></tr></table></figure><h5 id="函数的调用">函数的调用</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">函数名(参数)</span><br></pre></td></tr></table></figure><p>函数必须<strong>先定义</strong>，再使用</p><h5 id="return返回值">return返回值</h5><p>返回值也是函数执行的结果，可以用来赋值</p><p>不设置返回值返回<strong>None</strong></p><p><code>None</code>是一个特殊的字面量，类型为<code>NoneType</code></p><ul><li>一般用于if判断语句中，代表<code>False</code></li><li>也可以给一个变量赋值为<code>None</code>意为暂时没有具体值</li></ul><h5 id="return多个返回值">return多个返回值</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">myreturn</span>():</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>,<span class="literal">True</span>,<span class="string">&quot;hello&quot;</span></span><br><span class="line">x,y,z=myreturn()</span><br></pre></td></tr></table></figure><h5 id="函数的多种参数">函数的多种参数</h5><ul><li>位置参数：根据函数的形参位置顺序，依次传递参数，<strong>顺序个数必须一致</strong></li><li>关键字传参：函数调用时，在<code>()</code>里使用key(形参名)=value(实参)的方式进行传参，取消了参数传递的顺序要求，可以和位置参数混用</li><li>缺省参数：在函数定义时定义了参数的默认值，调用时不传该参数就使用默认值，无论定义还是调用，位置参数要在默认参数之前</li><li>不定长参数：不确定调用时会传入多少个参数（不传参也可以），分为位置不定长和关键字不定长两种</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#位置不定长</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">mytest</span>(<span class="params">*args</span>):</span><br><span class="line">    <span class="built_in">print</span>(args)</span><br><span class="line">mytest(<span class="string">&quot;hello&quot;</span>)</span><br><span class="line">mytest(<span class="string">&quot;hello&quot;</span>,<span class="string">&quot;world&quot;</span>,<span class="number">996</span>)</span><br><span class="line"><span class="comment">#会把接收到的参数变成一个元组</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#关键字不定长</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">mytest</span>(<span class="params">**kargs</span>):</span><br><span class="line">    <span class="built_in">print</span>(kargs)</span><br><span class="line">mytest(word1=<span class="string">&quot;hello&quot;</span>)</span><br><span class="line">mytest(word1=<span class="string">&quot;hello&quot;</span>,Word2=<span class="string">&quot;world&quot;</span>,num=<span class="number">996</span>)</span><br><span class="line"><span class="comment">#会把接收到的参数变成一个字典</span></span><br></pre></td></tr></table></figure><h5 id="匿名函数">匿名函数</h5><p><strong>匿名函数的定义</strong></p><p><code>lambda</code>关键字，可以定义<strong>匿名函数</strong>(无名称)</p><p><strong>有名称</strong>的函数(使用<code>def</code>定义的)，可以基于函数名<strong>无限次使用</strong></p><p>使用<code>lambda</code>定义的<strong>匿名函数</strong>只可以<strong>临时使用一次</strong></p><p><strong>定义</strong></p><p><code>lambda 参数:函数体(只能写一行代码，无法写多行)</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">myprint</span>(<span class="params">compute</span>):</span><br><span class="line">    <span class="built_in">print</span>(compute(<span class="number">1</span>,<span class="number">2</span>))</span><br><span class="line"></span><br><span class="line">myprint(<span class="keyword">lambda</span> x,y:x+y)</span><br><span class="line"><span class="comment">#不用写return，直接就return了</span></span><br></pre></td></tr></table></figure><p>前端OS：只能写一行，那我为啥不直接写表达式</p><h5 id="函数作为参数传递">函数作为参数传递</h5><p>前端OS：这可以当做特性来显摆吗？我一直以为所有语言都能这么玩</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">myprint</span>(<span class="params">compute</span>):</span><br><span class="line">    <span class="built_in">print</span>(compute(<span class="number">1</span>,<span class="number">2</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">compute</span>(<span class="params">a,b</span>):</span><br><span class="line">    <span class="keyword">return</span> a+b</span><br></pre></td></tr></table></figure><p>与<strong>普通传参</strong>不同，普通传参<strong>传的是数据</strong>，把<strong>函数</strong>作为参数传递，<strong>传递的是逻辑</strong></p><h5 id="函数的嵌套调用">函数的嵌套调用</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">b</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="number">2</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="number">3</span>)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">a</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="number">1</span>)</span><br><span class="line">    b()</span><br><span class="line">    <span class="built_in">print</span>(<span class="number">4</span>)</span><br><span class="line">a()</span><br></pre></td></tr></table></figure><p>在函数a中嵌套调用b，当a中的代码执行到b的时候，会在执行完b的所有代码后，再去执行a剩下的代码</p><h4 id="变量作用域">变量作用域</h4><p><strong>全局作用域</strong>和<strong>局部作用域</strong>两种</p><h5 id="局部变量">局部变量</h5><p><strong>局部变量</strong>是在函数体<strong>内部</strong>的变量</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">a</span>():</span><br><span class="line">    num=<span class="number">15</span></span><br><span class="line">    <span class="built_in">print</span>(num)</span><br><span class="line">a()</span><br><span class="line"><span class="built_in">print</span>(num) <span class="comment">#报错num未定义</span></span><br></pre></td></tr></table></figure><p>变量num的定义是在a函数内部，在外部访问报错</p><h5 id="全局变量">全局变量</h5><p>在函数<strong>体内</strong>，<strong>体外</strong>都能访问到的变量</p><p>如果非要在函数内部定义一个全局变量，可以使用global关键字</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">a</span>():</span><br><span class="line">    <span class="keyword">global</span> num=<span class="number">15</span></span><br><span class="line">    <span class="built_in">print</span>(num)</span><br><span class="line">a()</span><br><span class="line"><span class="built_in">print</span>(num) <span class="comment">#15</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">🐍纯前端没活路的，抓紧提升</summary>
    
    
    
    <category term="python学习日记" scheme="https://www.zshlmy.love/categories/python%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/"/>
    
    
    <category term="python" scheme="https://www.zshlmy.love/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>【前端八股文】防抖和节流,数组去重,深浅拷贝,import和require,export导出</title>
    <link href="https://www.zshlmy.love/posts/2023716d.html"/>
    <id>https://www.zshlmy.love/posts/2023716d.html</id>
    <published>2023-07-16T07:03:03.000Z</published>
    <updated>2023-07-16T12:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="防抖和节流">防抖和节流</h3><h4 id="防抖">防抖</h4><p>防抖是触发后在单位时间里，再次触发，会重新计算触发时间</p><p>可以理解成游戏里的回城，点击回城后，在回城过程里再次点击回城，回城会重新开始读条</p><p>非立即执行版的意思是触发事件后函数不会立即执行，而是在 n 秒后执行，如果在 n 秒内又触发了事件，则会重新计算函数执行时间。</p><p>立即执行版的意思是触发事件后函数会立即执行，然后 n 秒内不触发事件才能继续执行函数的效果。</p><h4 id="节流">节流</h4><p>节流是单位时间里，多次触发，事件只执行一次，会稀释函数执行频率</p><p>可以理解成游戏里的技能cd，cd没转好，点技能也没用</p><p>对于节流，一般有两种方式可以实现，分别是时间戳版和定时器版</p><h3 id="数组去重">数组去重</h3><ul><li>利用ES6 Set去重（ES6中最常用）</li><li>利用for嵌套for，然后使用splice去重（ES5中最常用）</li><li>利用indexOf去重</li><li>利用sort</li><li>利用includes</li><li>利用hasOwnProperty</li><li>利用filter</li><li>利用递归去重</li><li>利用Map数据结构去重</li></ul><h3 id="深浅拷贝">深浅拷贝</h3><p>深拷贝只针对Array和Object这种引用类型的数据</p><p>我们在定义一个引用类型的数据的变量后，JavaScript会为这个数据开辟一个内存空间，然后把这个内存空间的地址赋给这个变量</p><p>浅拷贝就是给新的变量拷贝这个引用数据的引用，新变量将引用原始数据的同一存储位置，因此对其中一个变量所做的更改会反映在另一个变量中，因为这两个变量的引用指向同一片内存空间</p><p>深拷贝会创建一个新的数据结构，并将原始数据的值复制到新的存储位置中，两个变量将引用不同的内存位置，因此对一个变量的更改不会影响到另一个变量</p><p><img src="https://img-blog.csdnimg.cn/img_convert/6e13a5cbeab9aaf0a19bcbf88d9b2cde.png" alt="avatar"></p><h4 id="深拷贝的方法">深拷贝的方法</h4><ul><li>JSON序列化与反序列化</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> clonedObject = <span class="title class_">JSON</span>.<span class="title function_">parse</span>(<span class="title class_">JSON</span>.<span class="title function_">stringify</span>(originalObject));</span><br></pre></td></tr></table></figure><ul><li>递归复制</li><li>使用第三方库，例如lodash的cloneDeep</li></ul><h3 id="import和require">import和require</h3><ul><li>在ES6模块系统中，import语句在代码编译阶段执行，而require在CommonJS模块系统中是在运行时执行的。</li><li>import语句必须放在文件的顶部，不能在条件语句或函数中动态导入模块，而require可以根据需要动态加载模块。</li><li>无论是import还是require，当导入的模块是可变对象时，修改导入的对象会影响原始对象，需要进行深拷贝操作以避免修改原始对象。</li><li>import语句有助于静态分析和优化，实现Tree-shaking（消除未使用的代码）的可能性，而require在CommonJS模块系统中不支持静态分析和优化。</li><li>import语句是ES6模块系统的一部分，需要在浏览器中使用时进行转换为ES5语法，通过构建工具（如Webpack、Babel）可以实现在现代浏览器中使用import语句。</li><li>require是Node.js中的模块系统，不直接适用于浏览器环境，但现代浏览器对ES6模块进行了广泛支持。</li><li>require使用module.exports导出模块，而import使用export关键字导出模块，支持具名导出和默认导出。</li><li>require通过相对路径或绝对路径解析模块，而import支持相对路径、绝对路径和模块名称解析，使用更先进的模块解析算法。</li><li>require适用于Node.js环境，import适用于现代浏览器和一些支持ES6模块的开发环境。</li></ul><p>需要注意的是，尽管现代浏览器和构建工具对import语法进行了广泛支持，但在特殊情况下可能需要进行转码或使用其他解决方案以实现更广泛的浏览器兼容性。</p><h3 id="export导出">export导出</h3><h4 id="默认导出">默认导出</h4><p>默认导出允许在一个模块中只导出一个默认的值，该值可以是任何类型，例如对象、函数或类。在导入时，不需要使用花括号，而是直接指定导入的名称。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">javascriptCopy code<span class="comment">// module.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">add</span>(<span class="params">a, b</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用默认导出</span></span><br><span class="line"><span class="comment">// main.js</span></span><br><span class="line"><span class="keyword">import</span> add <span class="keyword">from</span> <span class="string">&#x27;./module.js&#x27;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">add</span>(<span class="number">2</span>, <span class="number">3</span>)); <span class="comment">// 输出: 5</span></span><br></pre></td></tr></table></figure><h4 id="具名导出">具名导出</h4><p>具名导出允许在一个模块中导出多个变量、函数或类，并使用花括号指定要导入的名称。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">javascriptCopy code<span class="comment">// module.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> name = <span class="string">&#x27;John&#x27;</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">sayHello</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Hello, <span class="subst">$&#123;name&#125;</span>!`</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用具名导出</span></span><br><span class="line"><span class="comment">// main.js</span></span><br><span class="line"><span class="keyword">import</span> &#123; name, sayHello &#125; <span class="keyword">from</span> <span class="string">&#x27;./module.js&#x27;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(name);      <span class="comment">// 输出: John</span></span><br><span class="line"><span class="title function_">sayHello</span>();             <span class="comment">// 输出: Hello, John!</span></span><br></pre></td></tr></table></figure><h4 id="分别导出">分别导出</h4><p>分别导出允许在一个模块中同时使用默认导出和具名导出。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">javascriptCopy code<span class="comment">// module.js</span></span><br><span class="line"><span class="keyword">const</span> name = <span class="string">&#x27;John&#x27;</span>;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">sayHello</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Hello, <span class="subst">$&#123;name&#125;</span>!`</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> &#123; name, sayHello &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">add</span>(<span class="params">a, b</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用分别导出</span></span><br><span class="line"><span class="comment">// main.js</span></span><br><span class="line"><span class="keyword">import</span> add, &#123; name, sayHello &#125; <span class="keyword">from</span> <span class="string">&#x27;./module.js&#x27;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">add</span>(<span class="number">2</span>, <span class="number">3</span>)); <span class="comment">// 输出: 5</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(name);      <span class="comment">// 输出: John</span></span><br><span class="line"><span class="title function_">sayHello</span>();             <span class="comment">// 输出: Hello, John!</span></span><br></pre></td></tr></table></figure><h4 id="导出重命名">导出重命名</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// module.js</span></span><br><span class="line"><span class="type">const</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&#x27;John&#x27;</span>;</span><br><span class="line">export &#123; name as firstName &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用重命名的导出变量</span></span><br><span class="line"><span class="comment">// main.js</span></span><br><span class="line"><span class="keyword">import</span> &#123; firstName &#125; from <span class="string">&#x27;./module.js&#x27;</span>;</span><br><span class="line">console.log(firstName); <span class="comment">// 输出: John</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">📚太难了，摆了摆了</summary>
    
    
    
    <category term="前端八股文" scheme="https://www.zshlmy.love/categories/%E5%89%8D%E7%AB%AF%E5%85%AB%E8%82%A1%E6%96%87/"/>
    
    
    <category term="面试" scheme="https://www.zshlmy.love/tags/%E9%9D%A2%E8%AF%95/"/>
    
    <category term="前端八股文" scheme="https://www.zshlmy.love/tags/%E5%89%8D%E7%AB%AF%E5%85%AB%E8%82%A1%E6%96%87/"/>
    
  </entry>
  
  <entry>
    <title>【前端八股文】ES6新特性,面向对象编程,事件循环,null和undefined,前端缓存的理解</title>
    <link href="https://www.zshlmy.love/posts/2023715d.html"/>
    <id>https://www.zshlmy.love/posts/2023715d.html</id>
    <published>2023-07-15T10:19:03.000Z</published>
    <updated>2023-07-15T14:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="ES6新特性">ES6新特性</h3><h4 id="块级作用域">块级作用域</h4><p>引入<code>let</code>和<code>const</code>关键字，允许在块级作用域中声明变量和常量，解决了以前使用<code>var</code>关键字带来的作用域问题</p><h4 id="箭头函数">箭头函数</h4><p>提供了一种更简洁的函数定义语法，使用<code>=&gt;</code>箭头符号，可以减少函数声明的代码量</p><h4 id="默认参数">默认参数</h4><p>在函数定义时设置参数的默认值，在不传入参数时使用默认值</p><h4 id="扩展运算符">扩展运算符</h4><p>在函数调用，数组，对象中展开数组或对象</p><h4 id="解构赋值">解构赋值</h4><p>允许通过模式匹配的方法从数组或对象中解析出值，并赋给变量，可以快速获取使用值</p><h4 id="模板字符串">模板字符串</h4><p>使用反引号`包裹字符串，使用<code>$&#123;&#125;</code>插入变量和表达式，支持多行字符串的书写</p><h4 id="类">类</h4><p>引入类<code>class</code>的概念，并通过<code>constructor</code>方法定义构造函数，简化了面向对象编程</p><h4 id="模块化">模块化</h4><p>ES6引入了原生的模块系统，使用<code>import</code>和<code>export</code>关键字可以方便地导入和导出模块，提供了更好的代码组织和复用</p><h4 id="Promise和异步await">Promise和异步await</h4><p>引入了Promise对象和异步/await语法，提供了更好的异步编程方式，避免了回调地狱</p><h4 id="Map和Set">Map和Set</h4><p>引入了Map和Set两种新的数据结构，提供了更方便高效的数据存储和操作方式</p><h4 id="数组方法">数组方法</h4><ol><li><code>find()</code>：返回数组中满足条件的第一个元素。</li><li><code>findIndex()</code>：返回数组中满足条件的第一个元素的索引。</li><li><code>filter()</code>：返回数组中满足条件的所有元素组成的新数组。</li><li><code>forEach()</code>：遍历数组中的每个元素，并执行指定的回调函数。</li><li><code>map()</code>：将数组中的每个元素进行处理，返回一个新数组。</li><li><code>some()</code>：判断数组中是否有至少一个元素满足指定条件。</li><li><code>every()</code>：判断数组中的所有元素是否都满足指定条件。</li><li><code>reduce()</code>：对数组中的元素进行累加或累积计算。</li><li><code>includes()</code>：判断数组是否包含指定的元素。</li><li><code>Array.from()</code>：将类似数组的对象或可迭代对象转换为真正的数组。</li></ol><h4 id="字符串方法">字符串方法</h4><ol><li><code>startsWith()</code>：判断字符串是否以指定的字符开头。</li><li><code>endsWith()</code>：判断字符串是否以指定的字符结尾。</li><li><code>includes()</code>：判断字符串是否包含指定的字符。</li><li><code>repeat()</code>：重复字符串指定次数。</li><li><code>padStart()</code>：在字符串的开头添加指定字符，直到字符串达到指定长度。</li><li><code>padEnd()</code>：在字符串的结尾添加指定字符，直到字符串达到指定长度。</li><li><code>trim()</code>：去除字符串两端的空格。</li></ol><h3 id="面向对象编程">面向对象编程</h3><h4 id="面向对象的特征">面向对象的特征</h4><p>1、“抽象”，把现实世界中的某一类东西，提取出来，用程序代码表示；</p><p>2、“封装”，把过程和数据包围起来，对数据的访问只能通过已定义的界面；</p><p>3、“继承”，一种联结类的层次模型；</p><p>4、“多态”，允许不同类的对象对同一消息做出响应。</p><h3 id="事件循环">事件循环</h3><p>事件循环过程确保了 JavaScript 在单线程环境下的异步执行</p><p>通过将异步任务转换为微任务，在适当的时机执行，保证了任务的顺序性和及时性</p><ol><li><p>同步任务执行，这个过程可能会产生微任务，将微任务加入到微任务队列中</p></li><li><p>微任务执行，微任务执行的时候可能会产生新的微任务，系统会将所有微任务执行完成，直到微任务队列为空</p></li><li><p>执行宏任务，执行过程可能会产生微任务，将微任务加入到微任务队列中</p></li><li><p>微任务执行，微任务执行的时候可能会产生新的微任务，系统会将所有微任务执行完成，直到微任务队列为空</p></li><li><p>执行下一个宏任务，执行过程可能还会产生微任务，将微任务加入到微任务队列中</p></li></ol><p>再次执行2，如此往复，事件就循环起来了</p><h3 id="null和undefined">null和undefined</h3><p>undefined代表未定义的，通常是</p><ul><li>定义一个变量没有初始化，JavaScript就会给他一个undefined</li><li>没有给一个形参传实参，那么这个形参的变量值为undefined</li><li>一个没有指定返回值的函数调用后返回undefined</li></ul><p>null代表一个空值，JavaScript不会主动给一个变量设置null，JavaScript只会给一个未初始化的变量设置为undefined，它是用来让程序员表明某个用var声明的变量时没有值</p><h3 id="前端缓存的理解-前端数据持久化的理解">前端缓存的理解 || 前端数据持久化的理解</h3><p>http缓存是做http请求传输时带上的缓存，一般是后端配置，主要在服务器代码上配置，浏览器缓存一般是前端在js中配置的</p><p>一个优秀的缓存策略可以缩短网页请求资源的距离，减少延迟，并且由于<strong>缓存文件可以重复利用</strong>，还可以减少带宽，降低网络负荷</p><p>缓存是最简单高效的数据请求优化方法，数据请求可分为，发送请求，后端处理，浏览器响应三个阶段，缓存可以在一和三中进行优化，比如直接使用缓存不请求数据，或者前端发送请求，但后端和前端数据一样，后端就不用回传数据，减少浏览器响应数据</p>]]></content>
    
    
    <summary type="html">📚行了，已经准备卷铺盖回家了</summary>
    
    
    
    <category term="前端八股文" scheme="https://www.zshlmy.love/categories/%E5%89%8D%E7%AB%AF%E5%85%AB%E8%82%A1%E6%96%87/"/>
    
    
    <category term="面试" scheme="https://www.zshlmy.love/tags/%E9%9D%A2%E8%AF%95/"/>
    
    <category term="前端八股文" scheme="https://www.zshlmy.love/tags/%E5%89%8D%E7%AB%AF%E5%85%AB%E8%82%A1%E6%96%87/"/>
    
  </entry>
  
  <entry>
    <title>【前端八股文】this,apply,call,bind,作用域链,原型链,闭包</title>
    <link href="https://www.zshlmy.love/posts/2023627d.html"/>
    <id>https://www.zshlmy.love/posts/2023627d.html</id>
    <published>2023-06-27T08:38:45.000Z</published>
    <updated>2023-12-08T08:43:59.483Z</updated>
    
    <content type="html"><![CDATA[<h2 id="【前端八股文】promise-箭头函数-var-let-const">【前端八股文】promise,箭头函数,var,let,const</h2><h3 id="this">this</h3><h4 id="函数中this的指向问题">函数中this的指向问题</h4><p>谁调用函数，this就指向谁</p><h5 id="全局作用域">全局作用域</h5><p>在全局作用域中，函数没有被绑定到任何对象上，this指向全局对象（浏览器环境下是window，在node.js环境中this指向global）</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>)</span><br></pre></td></tr></table></figure><h5 id="函数调用">函数调用</h5><p>当函数作为一个独立函数调用时，函数中this指向全局对象</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">mythis</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="方法调用">方法调用</h5><p>当一个函数作为一个对象的方法时，this指向这个对象</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj=&#123;</span><br><span class="line">    <span class="attr">name</span>:<span class="string">&quot;jack&quot;</span>,</span><br><span class="line">    <span class="attr">sayHello</span>:<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Hello,&#x27;</span>+<span class="variable language_">this</span>.<span class="property">name</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">obj.<span class="title function_">sayHello</span>()</span><br><span class="line"><span class="comment">//this指向obj这个对象</span></span><br></pre></td></tr></table></figure><h5 id="构造函数">构造函数</h5><p>当一个函数用new关键字作为一个构造函数调用创建一个新实例的时候，this指向这个新的实例</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params">name</span>)&#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span>=name</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> jack=<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&#x27;jack&#x27;</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(jack.<span class="property">name</span>)</span><br></pre></td></tr></table></figure><h5 id="显式绑定">显式绑定</h5><p>通过call(),apply()，可以显式的指定函数的this值</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">sayHello</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Hello,&#x27;</span>+<span class="variable language_">this</span>.<span class="property">name</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> obj1=&#123;<span class="attr">name</span>:<span class="string">&#x27;jack&#x27;</span>&#125;</span><br><span class="line"><span class="keyword">const</span> obj2=&#123;<span class="attr">name</span>:<span class="string">&#x27;john&#x27;</span>&#125;</span><br><span class="line">sayHello.<span class="title function_">apply</span>(obj1)</span><br><span class="line">sayHello.<span class="title function_">call</span>(obj2)</span><br></pre></td></tr></table></figure><h5 id="箭头函数">箭头函数</h5><p>箭头函数的this是在一开始就定义好的，而不是在运行时确定的，他会继承外部作用域的this值</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj=&#123;</span><br><span class="line">    <span class="attr">name</span>:jack,</span><br><span class="line">    <span class="attr">sayHello</span>:<span class="function">()=&gt;</span>&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Hello,&#x27;</span>+<span class="variable language_">this</span>.<span class="property">name</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">obj.<span class="title function_">sayHello</span>()</span><br><span class="line"><span class="comment">//箭头函数的this指向外部作用域的this，这里输出Hello，undefined</span></span><br></pre></td></tr></table></figure><h3 id="bind，apply，call">bind，apply，call</h3><p>共同点：都是JavaScript内置方法，都改变this指向，都要接收一个要改变为this指向的对象</p><p>不同点：</p><p>​bind是返回一个新的已经改变了this指向的函数，不会立即调用，但这会永久改变this指向</p><p>​apply和call都是立即调用，只改变一次this指向</p><p>​call是一个，一个传参数，apply是传一个数组或一个类数组</p><p>call和apply第一个参数为null或undefined时，指向全局对象</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> person = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;John&#x27;</span>,</span><br><span class="line">  <span class="attr">greet</span>: <span class="keyword">function</span>(<span class="params">message</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(message + <span class="string">&#x27;, &#x27;</span> + <span class="variable language_">this</span>.<span class="property">name</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> person2 = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;Jane&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 call 方法调用 person 对象的 greet 方法，并将 this 设置为 person2，传递参数 &#x27;Hello&#x27;</span></span><br><span class="line">person.<span class="property">greet</span>.<span class="title function_">call</span>(person2, <span class="string">&#x27;Hello&#x27;</span>); </span><br><span class="line"><span class="comment">// 输出: &quot;Hello, Jane&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 apply 方法调用 person 对象的 greet 方法，并将 this 设置为 person2，传递参数数组 [&#x27;Hi&#x27;]</span></span><br><span class="line">person.<span class="property">greet</span>.<span class="title function_">apply</span>(person2, [<span class="string">&#x27;Hi&#x27;</span>]); </span><br><span class="line"><span class="comment">// 输出: &quot;Hi, Jane&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 bind 方法创建一个新函数，并将 this 设置为 person2</span></span><br><span class="line"><span class="keyword">const</span> greetPerson2 = person.<span class="property">greet</span>.<span class="title function_">bind</span>(person2);</span><br><span class="line"><span class="comment">// 调用新创建的函数，并传递参数 &#x27;Hola&#x27;</span></span><br><span class="line"><span class="title function_">greetPerson2</span>(<span class="string">&#x27;Hola&#x27;</span>);</span><br><span class="line"><span class="comment">// 输出: &quot;Hola, Jane&quot;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="原型链">原型链</h3><p>在某些时候我们可以在构造函数的prototype中添加一些方法，使用这个构造函数创建的实例对象都会带上这个方法，当我们在一个对象上调用方法的时候，如果他在自身上找不到这个方法，他会在原型链上往上找，原型链的顶端是null</p><p>在浏览器打印的[[prototype]]和__ <em>proto</em> _ _是等价的</p><p>每个JavaScript对象都有原型对象，对象可以通过__ <em>proto</em> _ <em>来访问他的原型，对象的</em>_ <em>proto</em> _ _指向他的构造函数的prototype</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义一个构造函数</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params">name</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在构造函数的原型上定义一个方法</span></span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">sayHello</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Hello, my name is &quot;</span> + <span class="variable language_">this</span>.<span class="property">name</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个实例对象</span></span><br><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Alice&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用实例对象的方法</span></span><br><span class="line">person1.<span class="title function_">sayHello</span>(); <span class="comment">// 输出: Hello, my name is Alice</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建另一个实例对象</span></span><br><span class="line"><span class="keyword">var</span> person2 = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Bob&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用另一个实例对象的方法</span></span><br><span class="line">person2.<span class="title function_">sayHello</span>(); <span class="comment">// 输出: Hello, my name is Bob</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="作用域链">作用域链</h3><p>当JavaScript执行时，每个函数都会创建一个作用域链，包含活跃对象和[[Scope]]</p><p>活跃对象包含函数的局部变量和参数</p><p>[[Scope]]属性指向当前函数所在作用域上的所有父级作用域</p><p>如果要获取一个变量的值没有在活跃对象上找到，他会去[[Scope]]上继续寻找，直到找到该变量或达到全局作用域</p><h3 id="闭包">闭包</h3><h4 id="闭包的产生">闭包的产生</h4><p>函数嵌套，内部函数可以引用外部函数作用域中的变量</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">outerFunction</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> outerVariable = <span class="string">&#x27;I am from outer function&#x27;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">innerFunction</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(outerVariable); <span class="comment">// 内部函数引用外部函数的变量</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> innerFunction; <span class="comment">// 返回内部函数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> closure = <span class="title function_">outerFunction</span>(); <span class="comment">// 调用外部函数，得到内部函数的引用</span></span><br><span class="line"></span><br><span class="line"><span class="title function_">closure</span>(); <span class="comment">// 输出: &quot;I am from outer function&quot;</span></span><br></pre></td></tr></table></figure><h4 id="闭包的作用">闭包的作用</h4><p><strong>保护变量</strong>：闭包可以创建一个私有的作用域，将变量隐藏起来，只能通过内部函数来访问和修改。这样可以防止外部对变量的意外修改和访问，实现了数据的封装和保护。</p><p><strong>实现数据的持久化</strong>：由于闭包的特性，内部函数持有对外部函数作用域的引用，使得外部函数的变量不会在函数执行完毕后被销毁。这样，可以通过闭包将数据持久化，使得数据在函数执行完毕后仍然存在，并可以被后续的操作所使用。</p><h4 id="闭包的缺点">闭包的缺点</h4><p>会造成内存泄漏，因为被闭包保护的数据仍然被引用，js的v8引擎垃圾回收机制不会去回收内存</p><h4 id="闭包的处理">闭包的处理</h4><p>当闭包持有大量数据时，可能会导致内存泄漏。为了避免内存泄漏，应该注意在不需要使用闭包时解除对其的引用，让垃圾回收机制回收不再需要的内存。可以手动解除引用</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">closure = <span class="literal">null</span></span><br></pre></td></tr></table></figure><p>或者使用一些技术手段如 WeakMap 来解决内存泄漏问题。</p>]]></content>
    
    
    <summary type="html">🏃项目经理今天开始赶我走了</summary>
    
    
    
    <category term="前端八股文" scheme="https://www.zshlmy.love/categories/%E5%89%8D%E7%AB%AF%E5%85%AB%E8%82%A1%E6%96%87/"/>
    
    
    <category term="面试" scheme="https://www.zshlmy.love/tags/%E9%9D%A2%E8%AF%95/"/>
    
    <category term="前端八股文" scheme="https://www.zshlmy.love/tags/%E5%89%8D%E7%AB%AF%E5%85%AB%E8%82%A1%E6%96%87/"/>
    
  </entry>
  
  <entry>
    <title>【前端八股文】promise,箭头函数,var,let,const</title>
    <link href="https://www.zshlmy.love/posts/2023626d.html"/>
    <id>https://www.zshlmy.love/posts/2023626d.html</id>
    <published>2023-06-25T10:19:03.000Z</published>
    <updated>2023-06-26T14:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="【前端八股文】promise-箭头函数-var-let-const">【前端八股文】promise,箭头函数,var,let,const</h2><h3 id="promise">promise</h3><p>promise是JavaScript中用来处理异步操作的对象，代表了一个异步操作的最终结果</p><p>new Promise（（resolve，reject）=&gt;{…}）这里的resolve和inject是等会通过then和catch传入的两个回调函数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 异步函数，返回一个Promise对象</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">fetchData</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line"> <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123; </span><br><span class="line"><span class="comment">//这里的resolve是等会通过then传入成功的回调</span></span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">   <span class="title function_">resolve</span>(<span class="string">&#x27;Data fetched&#x27;</span>);</span><br><span class="line"><span class="comment">//这里的resolve是调用promise的resolve方法把promise状态设置为成功</span></span><br><span class="line">  &#125;, <span class="number">2000</span>);</span><br><span class="line"> &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用async关键字定义的异步函数</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">getData</span> = <span class="keyword">async</span> (<span class="params"></span>) =&gt; &#123;</span><br><span class="line"> <span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Fetching data...&#x27;</span>);</span><br><span class="line">  <span class="keyword">const</span> result = <span class="keyword">await</span> <span class="title function_">fetchData</span>(); <span class="comment">// 等待Promise对象的解析</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(result);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Data fetched successfully!&#x27;</span>);</span><br><span class="line"> &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">&#x27;Error:&#x27;</span>, error);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用异步函数</span></span><br><span class="line"><span class="title function_">getData</span>();</span><br></pre></td></tr></table></figure><p>promise是用来解决回调地狱问题，promsie可以用来做网络请求，定时器操作，文件读写操作等</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">delay</span> = (<span class="params">milliseconds</span>) =&gt; &#123;</span><br><span class="line"> <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(resolve, milliseconds);</span><br><span class="line"> &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;开始执行&#x27;</span>);</span><br><span class="line"><span class="title function_">delay</span>(<span class="number">2000</span>)</span><br><span class="line"> .<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;延迟2秒后执行&#x27;</span>);</span><br><span class="line"> &#125;)</span><br><span class="line"> .<span class="title function_">catch</span>(<span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">&#x27;发生错误:&#x27;</span>, err);</span><br><span class="line"> &#125;);</span><br><span class="line"><span class="comment">//这个例子中体现了promise可以在执行完后再指定回调</span></span><br></pre></td></tr></table></figure><h4 id="promise的同步与异步">promise的同步与异步</h4><p>同步过程：</p><p>创建Promise对象：当调用Promise的构造函数时，创建Promise对象是同步执行的。<br>执行executor函数：executor函数会立即执行，它接收两个参数(resolve和reject)并立即执行其中之一。<br>返回Promise对象：Promise构造函数返回Promise对象本身，这也是同步操作。<br>异步过程：</p><p>处理.then()和.catch()：通过调用.then()和.catch()方法，可以为Promise对象添加成功和失败的回调函数。这些回调函数是异步执行的，它们会在Promise的状态改变后执行，而不会阻塞后续代码的执行。<br>异步操作的解析：如果在Promise对象的异步操作完成之前调用了.then()方法，成功回调函数会被加入到微任务队列中，并在当前同步代码执行完毕后执行。这样可以确保回调函数在异步操作完成后执行。<br>异步操作的延迟：如果在Promise对象的异步操作完成之前调用了.then()方法，异步操作的执行会被延迟到当前同步代码执行完毕后才会开始。</p><p>总之，Promise的创建和执行executor函数是同步的过程，而处理.then()和.catch()以及异步操作的解析和延迟是异步的过程。这种异步性质使得Promise能够更好地处理异步操作，并避免了回调地狱的问题。</p><p>promise的主体部分代码是同步执行，then和catch是异步执行的</p><h4 id="promsie的状态">promsie的状态</h4><p>promise有三种状态，pending，rejected（失败），fullfilled（成功）</p><p>Promise的状态一旦改变，就不会再变，任何时候都可以得到这个结果，状态不可以逆，只能由 pending变成fulfilled或者由pending变成rejected</p><h4 id="promise的优点">promise的优点</h4><p>promise的返回值还是promise，使用then来指定回调，使用catch来捕获错误，catch可以放在最后统一捕获错误</p><p>promise相比于传统链式回调的优点在于：传统链式回调要在有结果之前就提前指定好回调，promise可以在获取结果之后再去指定回调</p><h4 id="promise的缺点">promise的缺点</h4><ul><li><p>无法取消Promise,一旦新建它就会立即执行，无法中途取消</p></li><li><p>如果不设置回调函数，Promise内部抛出的错误，不会反映到外部</p></li><li><p>当处于pending状态时，无法得知目前进展到哪一个阶段，是刚刚开始还是即将完成</p></li></ul><h4 id="promise的方法">promise的方法</h4><p>promise几种常用方法，除了then用来指定成功时的回调和catch用来捕获错误还有：</p><p>race和all，race会将最先有结果的promise最为整个promise的结果，all会在所有promise都有结果后再返回结果，如果有一个promise是失败的，那么整个promise的结果都是失败的，all方法返回的promise是一个数组，包含所有promise的结果</p><p>finally无论成功还是失败都会调用的回调</p><p>常用的方法还有reject和resolve，resolve传入的参数是对的就返回成功的promise，resolve的参数是失败的就返回失败的promise，无论reject的参数是什么都返回失败的promise</p><h4 id="async和await的使用">async和await的使用</h4><p>我们还可以使用async和await让代码更加简洁易读</p><h3 id="箭头函数">箭头函数</h3><h4 id="箭头函数与普通函数的区别：">箭头函数与普通函数的区别：</h4><ol><li>箭头函数没有自己的this，因此在确定this的值时需要通过查找作用域链。如果箭头函数被非箭头函数包含，this绑定的就是最近一层非箭头函数的this。</li><li>箭头函数没有自己的arguments对象，但可以访问外围函数的arguments对象。</li><li>箭头函数不能通过new关键字调用，也没有new.target[^new.target]值和原型。</li></ol><h4 id="箭头函数的特点：">箭头函数的特点：</h4><ol><li><p>语法更加简洁、清晰。</p></li><li><p>箭头函数继承而来的this指向永远不变，它只会从自己的作用域链的上一层继承this。</p></li><li><p>.call()/.apply()/.bind()无法改变箭头函数中this的指向。</p></li><li><p>箭头函数不能用作构造函数，不能通过new关键字实例化。</p></li><li><p>箭头函数没有自己的arguments对象，可以使用rest参数来访问箭头函数的参数列表。</p></li><li><p>箭头函数没有原型prototype。</p></li><li><p>箭头函数不能用作Generator函数，不能使用yield关键字。</p></li><li><p>箭头函数不具有super，也不具有new.target[^new.target]</p><p>[^new.target]: 当使用 <code>new</code> 关键字调用构造函数创建实例时，<code>new.target</code> 会引用正在被构造的对象的构造函数。换句话说，它提供了对正在被构造的类或构造函数的引用</p></li></ol><h3 id="var-let-const">var,let,const</h3><h4 id="var">var</h4><ul><li>全局声明：使用<code>var</code>关键字声明的变量具有全局作用域，可以在代码中的任何位置访问。</li><li>变量提升：在变量声明之前就可以访问变量，但其值会是<code>undefined</code>。这是因为变量声明会被提升到作用域的顶部，但变量赋值的操作会保留在原来的位置。</li><li>可重复定义：可以在同一作用域内多次使用<code>var</code>声明同一个变量，后面的声明会覆盖前面的声明。</li><li>可修改值：使用<code>var</code>声明的变量的值是可变的，可以通过赋值运算符进行修改</li></ul><p>var只有全局作用域和函数作用域，所谓全局作用域就是在代码的任何位置都能访问var声明的变量，而函数作用域在变量声明的当前函数内部访问变量。函数外部是无法访问函数内部声明的变量的</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">example</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> y = <span class="number">20</span>; <span class="comment">// 函数作用域</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(y); <span class="comment">// 在函数内部可以访问变量y</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">example</span>(); <span class="comment">// 输出: 20</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(y); <span class="comment">// 报错: ReferenceError: y is not defined</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">example</span>(<span class="params"></span>) &#123;</span><br><span class="line">  y = <span class="number">20</span>; <span class="comment">// 函数作用域</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(y); <span class="comment">// 在函数内部可以访问变量y</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">example</span>(); <span class="comment">// 输出: 20</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(y); <span class="comment">// 输出: 20</span></span><br></pre></td></tr></table></figure><h4 id="let">let</h4><ul><li><p>块级作用域：使用<code>let</code>关键字声明的变量具有块级作用域，仅在其声明的块内部可见。</p></li><li><p>不能重复定义：在同一作用域内，不能使用<code>let</code>重新声明已存在的变量。这样可以避免变量的重复定义和潜在的错误。</p></li><li><p>可修改值：使用<code>let</code>声明的变量的值是可变的，可以通过赋值运算符进行修改。</p></li><li><p>其实是存在变量提升的，但是有暂时性死区[^暂时性死区]</p></li></ul><h4 id="const">const</h4><ul><li>块级作用域：使用<code>const</code>关键字声明的变量同样具有块级作用域，仅在其声明的块内部可见。</li><li>必须初始化：使用<code>const</code>声明变量时必须进行初始化，即必须给变量赋初始值。</li><li>不能修改值：使用<code>const</code>声明的变量是常量，其值在初始化后就不能被修改，尝试修改将会导致错误。</li><li>其实是存在变量提升的，但是有暂时性死区[^暂时性死区]</li></ul><p>需要注意的是，虽然使用<code>const</code>声明的变量值不能被直接修改，但对于复合类型（如对象和数组），其内部的属性或元素是可以被修改的。<code>const</code>只保证变量绑定的引用不变，而不保证引用指向的对象不变。</p><table><thead><tr><th></th><th>var</th><th>let</th><th>const</th></tr></thead><tbody><tr><td>作用域</td><td>函数作用域/全局作用域</td><td>块级作用域</td><td>块级作用域</td></tr><tr><td>声明提升</td><td>提升变量名和初始化</td><td>仅提升变量名，不包括初始化</td><td>仅提升变量名，不包括初始化</td></tr><tr><td>暂时性死区</td><td>无</td><td>存在，访问会抛出 <code>ReferenceError</code> 错误</td><td>存在，访问会抛出 <code>ReferenceError</code> 错误</td></tr><tr><td>重复声明</td><td>允许</td><td>不允许</td><td>不允许</td></tr><tr><td>全局声明时作为window的属性</td><td>是</td><td>否</td><td>否</td></tr></tbody></table><p>[^暂时性死区]: 变量声明会在作用域的顶部进行提升，但初始化被留在原地，直到定义位置之后的代码才会执行。在变量声明之前访问该变量会导致暂时性死区（TDZ）的出现，会抛出 <code>ReferenceError</code> 错误。只有在声明语句执行之后，变量才会进入到可访问的状态</p>]]></content>
    
    
    <summary type="html">📚失业了，快复习复习找新工作</summary>
    
    
    
    <category term="前端八股文" scheme="https://www.zshlmy.love/categories/%E5%89%8D%E7%AB%AF%E5%85%AB%E8%82%A1%E6%96%87/"/>
    
    
    <category term="面试" scheme="https://www.zshlmy.love/tags/%E9%9D%A2%E8%AF%95/"/>
    
    <category term="前端八股文" scheme="https://www.zshlmy.love/tags/%E5%89%8D%E7%AB%AF%E5%85%AB%E8%82%A1%E6%96%87/"/>
    
  </entry>
  
</feed>
